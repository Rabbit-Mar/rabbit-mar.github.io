{"meta":{"title":"Marveal Rabbit","subtitle":"MR","description":"Marveal Rabbit 的个人博客网站","author":"Marveal Rabbit","url":"https://rabbit-mar.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-18T07:12:43.125Z","updated":"2021-02-18T07:12:43.124Z","comments":false,"path":"/404.html","permalink":"https://rabbit-mar.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-18T07:12:43.150Z","updated":"2021-02-18T07:12:43.150Z","comments":false,"path":"about/index.html","permalink":"https://rabbit-mar.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2021-02-18T07:12:43.192Z","updated":"2021-02-18T07:12:43.192Z","comments":false,"path":"tags/index.html","permalink":"https://rabbit-mar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 第31题:下一个排列","slug":"LeetCode 第31题 下一个排列","date":"2021-02-18T11:51:01.000Z","updated":"2021-02-18T11:53:05.241Z","comments":true,"path":"2021/02/18/LeetCode 第31题 下一个排列/","link":"","permalink":"https://rabbit-mar.github.io/2021/02/18/LeetCode%20%E7%AC%AC31%E9%A2%98%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","excerpt":"","text":"31. 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 题目来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/next-permutation著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题目分析输入一串数组例如 nums 1 2 4 3 2 index 0 1 2 3 4 找出下一个更大的排列，即 nums 1 3 2 2 4 index 0 1 2 3 4 可以找打规律从右向左遍历，找到一个拐点的时候，如上例所示，即 2、4、3、22在2、3、4这样的逆序排列中，突然递减，此时可以找到一个更大的排列 如图所示，只需要找到2之后的节点，并且离2最接近的节点进行交换 然后将3之后的节点进行排序，就拿到了1、3、2、2、4这个顺序 代码实现123456789101112131415161718192021222324252627282930313233343536373839public void nextPermutation(int[] nums) &#123; int len = nums.length; for (int i = len - 1; i &gt; 0; i--) &#123; if (nums[i-1] &lt; nums[i]) &#123; int aim = getClosestNum(nums, i-1); swap(nums, i-1, aim); Arrays.sort(nums, i, len); return; &#125; &#125; // 降序排列 Arrays.sort(nums);&#125;// 交换public void swap(int[] nums, int source, int target)&#123; int tmp = nums[source]; nums[source] = nums[target]; nums[target] = tmp;&#125;public int getClosestNum(int[] nums, int idx)&#123; int len = nums.length; int seek = idx + 2; // 游标i int aim = idx+1; // 初始化最接近的下标 int gap = nums[aim] - nums[idx];//差值 // 开始遍历后续节点，找到最接近拐点前的那个值 while (seek &lt;= len-1) &#123; if (nums[seek] &gt; nums[idx] &amp;&amp; (nums[seek] - nums[idx]) &lt; gap) &#123; aim = seek; gap = nums[seek] - nums[idx]; &#125; seek++; &#125; return aim;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://rabbit-mar.github.io/tags/LeetCode/"}]},{"title":"Redis学习之路(一)——Redis的安装","slug":"Redis学习之路(一)——Redis的安装","date":"2021-02-18T11:07:45.000Z","updated":"2021-02-18T11:50:36.472Z","comments":true,"path":"2021/02/18/Redis学习之路(一)——Redis的安装/","link":"","permalink":"https://rabbit-mar.github.io/2021/02/18/Redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF(%E4%B8%80)%E2%80%94%E2%80%94Redis%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"redis的安装及使用安装 打开redis官网 https://redis.io/ 找到download界面，复制下载链接 http://download.redis.io/releases/redis-6.0.1.tar.gz 然后在linux终端上用wget命令进行安装 wget http://download.redis.io/releases/redis-6.0.1.tar.gz 然后执行tar进行解压缩包 tar -zxvf redis-6.0.1.tar.gz 通过阅读redis-6.0.1下的README.MD可以自己进行安装，这里留下安装方式 3.1 输入make命令进行编译整个redis make 3.2 如果遇到cc命令没找到，就要先安装gcc，如果没有问题就跳转到3.5 3.3 执行yum安装gcc yum install gcc -y 3.4 安装完成后清除一下上一次make的缓存，然后再执行命令make，就行编译 make distclean &amp;&amp; make 3.5 如果还是报错server.c的问题，查看gcc的版本，然后升级gcc的版本,如果没有问题就跳转到3.7 12345678910111213# 查看gcc版本是否在5.3以上，centos7.6默认安装4.8.5gcc -v# 升级gcc到5.3及以上,如下：升级到gcc 9.3：yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutilsscl enable devtoolset-9 bash需要注意的是scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本。如果要长期使用gcc 9.3的话：echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile这样退出shell重新打开就是新版的gcc了以下其他版本同理，修改devtoolset版本号即可。 3.6 完成后再清理一次缓存，然后再make make distclean &amp;&amp; make 3.7 然后执行install命令进行安装，安装到/opt/redis/redis6目录下 mkdir /opt/redismkdir /opt/redis/redis6make PREFIX=/opt/redis/redis6 install 编辑/etc/profile文件，将redis命令安装到命令行快捷栏上 export REDIS_HOME=/opt/redis/redis6 export PATH=$PATH:$REDIS_HOME/bin 去设置redis为后台服务启动，进到redis安装目录下的utils,执行install_server.sh，进行安装 ./install_server.sh 如果出现问题，就去自己创建redis服务 6.1 拷贝一份conf文件到/etc/redis/下 cp /usr/lib/redis/redis-6.0.1/redis.conf /etc/redis/6380.conf 6.2 更改/etc/redis/下的配置文件 vim /etc/redis/6380.conf 1234567#下面要是改的参数 可以通过vim的&#x2F;查找port 6380daemonize yespidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pidlogfile &quot;&#x2F;var&#x2F;log&#x2F;redis_6380.log&quot;#这个是redis数据持久化存放的地方dir &#x2F;var&#x2F;lib&#x2F;redis&#x2F;6380 6.3 创建数据存放目录 mkdir /var/lib/redis/6380 6.4 创建service文件 vim /usr/lib/systemd/system/redis_6380.service 1234567891011121314[Unit]Description&#x3D;redis_6380After&#x3D;network.target[Service]Type&#x3D;forking#pid文件路径PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;redis_6380.pid#这就是执行命令 前面为redis-server所在路径 后一个为刚配置的conf文件ExecStart&#x3D;&#x2F;opt&#x2F;redis&#x2F;redis6&#x2F;bin&#x2F;redis-server &#x2F;etc&#x2F;redis&#x2F;6380.confExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPIDExecStop&#x3D;&#x2F;bin&#x2F;kill -s QUIT $MAINPIDPrivateTmp&#x3D;true[Install]WantedBy&#x3D;multi-user.target 6.5 启动service systemctl start redis_6380 6.6 根据需求可以再配一个本来端口6379的，会简单很多，两个可以一起启动 正式环境中有开机启动需求的话，就执行下方命令就行了 先创建一个符号链接 ln -s /usr/lib/systemd/system/redis_6379.service /etc/systemd/system/multi-user.target.wants/redis_6379.service systemctl list-unit-files | grep redis如果看到有这个出现就完成redis_6379.service enabled","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://rabbit-mar.github.io/tags/Redis/"}]}],"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://rabbit-mar.github.io/tags/LeetCode/"},{"name":"Redis","slug":"Redis","permalink":"https://rabbit-mar.github.io/tags/Redis/"}]}